---
title: "Class 12 RNAseq analysis"
author: "Jiayi Zhou (PID: A17856751)"
format: pdf
toc: true
---

## Background
Today we will analyze some RNASeq data from Himes et at. on the effects of a common steroid (dexamethasone) on airway smooth muscle cells (ASM cells).

Are starting points is the "counts" data and "metadata" that contain the count values for each gene in their different experiments (i.e. cell lines with or without the drug).

## Data import

```{r}
# Complete the missing code
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

Let's have a wee peak at these objects:

```{r}
head(counts)
```

> Q1.1. How many genes are in this dataset?

38,694 genes.

```{r}
nrow(counts)
```

> Q1.2. How many different experiments (columns in counts(metadata) are there?

8 different experiments.

```{r}
ncol(counts)
```

```{r}
metadata
```
> Q2. How many ‘control’ cell lines do we have?

4 'control' cell lines.

```{r}
sum(metadata$dex == "control")
```

## Toy differential gene expression

To start our analysis let's calculate the mean counts for all genes in the "control experiments.

1. Extract all "control" columns from the `counts` object
2. Calculate the mean for all rows (i.e. genes) of these "control" columns
3-4. Do the same for "treated".
5. Compare these `control.mean` and `treated.mean` values.

> Q3.  How would you make the above code in either approach more robust? Is there a function that could help here?

To make the code more robust, use rowMeans() instead of dividing by a fixed number so the calculation automatically adjusts to any number of samples.

```{r}
#Step 1. Extracted all the "control" columns
control.inds <- metadata$dex == "control"
control.counts <- counts[,control.inds]
head(counts[,control.inds])
```

```{r}
#Step 2, mean of all control columns.
control.means <- rowMeans(control.counts)
head(control.means)
```
> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

For the treated samples, select columns where `dex == "treated"` and calculate their per-gene averages using `rowMeans()` to create the `treated.means` vector.

```{r}
#Step 3. Extracted all the "treated" columns
treated.inds <- metadata$dex == "treated"
treated.counts <- counts[,treated.inds]
head(counts[,treated.inds])
```

```{r}
#Step 4, mean of all treated columns.
treated.means <- rowMeans(treated.counts)
head(treated.means)
```
Store these together for ease of bookkeeping as `meancounts`

```{r}
meancounts <- data.frame(control.means, treated.means)
head(meancounts)
```
```{r}
colSums(meancounts)
```

> Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

Make a plot of control vs treated mean values
```{r}
plot(meancounts, xlab="Control", ylab="Treated")
```
> Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?

use the geom_point() function.

```{r}
library(ggplot2)

ggplot(meancounts, aes(x = control.means, y = treated.means)) +
  geom_point(color = "blue", alpha = 0.4, size = 1) +
  labs(x = "Control", y = "Treated")
```

Make this a log log plot.

> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

Use the `log = "xy"` argument in `plot()`.

```{r}
plot(meancounts, log = "xy", xlab = "log Control", ylab = "log Treated")
```

We often talk metrics like "log2 fold-change"

```{r}
# treated/control
# 0=no change, positive=up regulated, negative=down regulated
log2(10/10)
log2(10/20) # half the amount
log2(20/20) # double the amount
```

Let's calculate the log2 fold change for our treated over control mean counts.
 
```{r}
meancounts$log2fc <- log2(meancounts$treated.means/meancounts$control.means)
head(meancounts)
```

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

>Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

The `arr.ind = TRUE` argument makes `which()` return both row and column indices of zero values, and taking the first column with `unique()` ensures we only keep each gene’s row index once even if it has multiple zeros.


A common "rule of thumb" is a log2 fold change cutoff of +2 and -2 to call genes "Up regulated" or "Down regulated".

> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level?

The number of up-regulated genes is sum(up.ind)
Number of "up" genes at +2 threshold
```{r}
sum(meancounts$log2fc >= +2, na.rm=T)
```

> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level?

The number of down-regulated genes is sum(down.ind)

Number of "down" genes at -2 threshold
```{r}
sum(meancounts$log2fc >= -2, na.rm=T)
```

> Q10. Do you trust these results? Why or why not?

No, these results are based on fold change without normalization or statistical significance testing (e.g., DESeq2 p-values).

## DESeq2 analysis

Let's do this analysis properly and keep our inner stats nerd happy - i.e. are the differences we see between drug and no drug significant given the replicate experiments.

```{r, message=FALSE}
library(DESeq2)
```

For DESeq analysis we need three things

- count values (`contData`)
- metadata telling us about the columns in `countdata` (coldata)
- design od the experiment (i.e.what do you want to compute)

Our first function from DESeq2 will set up the input required for analysis by storing all these 3 things together,

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = metadata,
                              design = ~dex)
```


The main function in DESeq2 that runs the analysis is caled `DESeq2`

```{r}
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
head(res)
```
```{r}
summary(res)

res05 <- results(dds, alpha=0.05)
summary(res05)
```

```{r}
36000*0.05
```


## Adding Annotation Data

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

```{r}
columns(org.Hs.eg.db)
```

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="SYMBOL",          # The new format we want to add
                     multiVals="first")
head(res)
```
> Q11. Run the mapIds() function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called res$entrez, res$uniprot and res$genename.

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

res$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="UNIPROT",
                     keytype="ENSEMBL",
                     multiVals="first")

res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="GENENAME",
                     keytype="ENSEMBL",
                     multiVals="first")

head(res)
```

```{r}
ord <- order( res$padj )
#View(res[ord,])
head(res[ord,])
```

```{r}
write.csv(res[ord,], "deseq_results.csv")
```


## Volcano Plot

This is a common summary result figure from these types of experiments and plot the log2 fold-change vs the adjusted p-value.

```{r}
plot(res$log2FoldChange, -log(res$padj))
abline(v=c(-2,2), col="red")
abline(h=-log(0.04), col="red")
```

```{r}
log(0.1)
log(0.000001)
```

```{r}
# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```

```{r}
BiocManager::install("EnhancedVolcano")
library(EnhancedVolcano)

x <- as.data.frame(res)

EnhancedVolcano(x,
    lab = x$symbol,
    x = 'log2FoldChange',
    y = 'pvalue')
```


## Save our results

```{r}
write.csv(res, file="my_results.csv")
```

## Add gene annotation

To help make sense of our results and continue them to other folks we need to add some more annotation to our main `res` object.

We will use two bioconductor packages to first map IDs to different formats including the classic gene "symbol" gene name.

I will install these with the following commands:
`BiocManager::install("AnnotationDbi")`
`BiocManager::install("org.Hs.eg.db")`

```{r}
library(AnnotationDbi)
library(org.Hs.eg.db)
```

Let's see what is in `org.Hs.eg.db` with the `columns()` function:

```{r}
columns(org.Hs.eg.db)
```
We can translate or "map" IDs between any of these 26 database using the `mapIds()` function.

```{r}
res$symbol <- mapIds(keys = row.names(res), # our current IDs
       keytype = "ENSEMBL",                 # the format of our IDs
       x = org.Hs.eg.db,                    # where to get mappings from
       column = "SYMBOL")                   # the format/DB to map to

head(res)
```

Add the mapping for "GENENAME" and "ENTREZID" and store as `res$genename` and `res$entrez`

```{r}
res$entrez <- mapIds(keys = row.names(res), # our current IDs
       keytype = "ENSEMBL",                 # the format of our IDs
       x = org.Hs.eg.db,                    # where to get mappings from
       column = "ENTREZID")                 # the format/DB to map to

res$genename <- mapIds(keys = row.names(res), # our current IDs
       keytype = "ENSEMBL",                 # the format of our IDs
       x = org.Hs.eg.db,                    # where to get mappings from
       column = "GENENAME") 
```

```{r}
head(res)
```

## Pathway analysis

There are lots of bioconductor packages to do this type of analysis. For now let's just try one called **gage** again we need to install this if we don't have it already.

```{r, message=FALSE}
library(gage)
library(gageData)
library(pathview)
```

To use **gage** I need two things

- a named vector of fold-change calues for our DEGs (our geneset of interest)
- a set of pathways or genesets to use for annotation

```{r}
c("barry"=5,"lisa"=10)
```

```{r}
names(x) <- c("low", "high")
x
```

```{r}
foldchanges <- res$log2FoldChange
names(foldchanges) <- res$entrez
head(foldchanges)
```

```{r}
data(kegg.sets.hs)

keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

In our results object we have:

```{r}
attributes(keggres)
```


```{r}
head(keggres$less, 5)
```

Let's look at one of thgese pathways with our genes colored up so we can see the overlap

```{r}
pathview(pathway.id = "hsa05310", gene.data = foldchanges)
```

Add this pathway figure to our lab report

![](hsa05310.png)

## Save our main results

```{r}
write.csv(res, file = "myresults_annotated.csv")
```

```{r}
rm class-12-html.rmarkdown
```
